/*
    자바 연산자
    1) 산술 연산자 : + - * / % **(거듭제곱 연산자)
    2) 증감 연산자 : ++ -- 
    3) 비교 연산자 : == 동등 === 일치 / != 동등하지 않음 !== 일치하지 않음 / >= <= > < 
    4) 논리 연산자 : && || ! (단항 연산자)
        - short circuit 기능 존재
    5) 삼항 연산자 : 조건연산자. (조건식) ? 참인경우 : 거짓일경우 ; 
                        => 참, 거짓 위치에 실행문이 들어갈 수 있어, 변수에 담지 않고 단독 사용 가능
    6) typeof : 단항연산자. 오른쪽의 변수가 어떤 타입인지 출력
    7) 비트연산자 : >> << ~ (1's complement 연산자로, 0은 1로, 1은 0으로 변경)
    8) 대입연산자 : left value(LV) = right value(RV)
        - LV는 변수만 가능.
    9) 복합대입연산자 : += -= /= 등
    10) 전개 연산자 (spread operator) : ...
        - 배열, 객체에 포함된 값들을 펼치는 연산자
        - 함수의 파라미터에서 사용
        - 대입연산자에서 사용
            - 변수, 변수 = ...배열
    
*/

let a = 3;
console.log(`${a}의 세제곱 = ${a ** 3}`);

let x = '3';
console.log(`${a}와 ${x}의 동등여부 : ${a == x}`); //true: 문자 열을 파싱했을 때 값이 같으면 같음.
console.log(`${a}와 ${x}의 일치여부 : ${a === x}`); // flase: 타입도 고려함

let b = 10;
console.log(`${b}가 0 ~ 50 사이의 값인가? ${b >= 0 && b <= 50}`); //true
console.log(`${b}가 0 ~ 50 사이의 값인가? ${0 <= b <= 50}`);
/*      자바에서는 오류, 자바스크립트에서는... 오류는 아니지만... 앞쪽의 연산을 적용 후, 뒤 연산 적용 
        0 <= b : true(1) <= 50 : true! b가 60이어도 true
*/

/*
    Short circuit(단축평가)
    - 왼쪽 연산의 결과에 따라 오른쪽 연산의 실행여부를 결정하는 기능
    - 논리연산자(&& ||) 사용

    && (둘 중 하나만 false 이면 결과도 false)
    - T && ? => ? : 전체 연산의 결과가 미지수이므로 두번째 연산을 실행함
    - F && ? => F : 첫번째 연산의 결과가 F이므로 전체 연산의 결과가 F. 두번째 연산을 실행하지 않음 => short circuit

    || (둘 중 하나만 true이면 결과도 true)
    - T || ? => T : 첫번째 연산의 결과가 T이므로 전체 연산의 결과가 T. 두번째 연산을 실행하지 않음 => short circuit
    - F || ? => ? : 전체 연산의 결과가 미지수이므로 두번째 연산을 실행함

*/
// ----단축평가 실습
let c = 1; // (시험 출제 예정)
c > 1 || console.log("실행되나?"); // false || 코드 => 실행됨


// ----삼항연산자 실습
let d = 5;
let e = 3;

d < e ? console.log(`${d}가 ${e}보다 크다.`) : console.log(`${d}가 ${e}보다 작다.`);


// ----전개 연산자 (spread 연산자) : 두 obj 데이터를 펼쳐 이음 (펼쳐진 결과가 달라야 쌓임)
let obj1 = { name: '홍길동' };
let obj2 = { name: '임꺽정' };
let obj3 = { addr: '제주도 제주시' };
console.log(obj1);
let obj12 = { ...obj1, ...obj2 };// 결과: { name: '임꺽정' }; => key값 name이 동일하기에 obj1의 홍길동에 obj2가 덮어 씌워짐
console.log(obj12);

let obj23 = { ...obj2, ...obj3 }; // 결과: { name: '임꺽정',addr: '제주도 제주시' };
console.log(obj23);

// let obj23_2 = [...obj2, ...obj3]; // 결과: 에러! 키값을 데이터로서 배열에 넣을 수 없는 문제.
//(Syntax오류는 아니지만 obj2, 3이 iterable이 아니기에 오류)
// console.log(obj23_2);

// 배열에 전개연산자 적용
let ary1 = [1, 3, 5, 7];
let ary2 = [2, 4, 6, 8];
let ary12 = [...ary1, ...ary2]; //결과 : [1, 3, 5, 7, 2, 4, 6, 8] => 정렬은 안되었으나, 뒤에 바로 이어짐
console.log(ary12);

let ary12_2 = { ...ary1, ...ary2 }; //결과 : {0: 2, 1: 4, 2: 6, 3: 8} 
// => 앞 배열의 위치값(방번호)이 key(0~3), 뒤 배열의 값이 value로서 사용됨
console.log(ary12_2); 